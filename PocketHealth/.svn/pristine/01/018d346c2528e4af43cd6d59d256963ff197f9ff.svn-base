//
//  AppDelegate.m
//  PocketHealth
//
//  Created by macmini on 15-1-5.
//  Copyright (c) 2015年 YiLiao. All rights reserved.
//

#import "AppDelegate.h"
#import "BPush.h"
#import "CommonUtil.h"
#import "PHAppStartManager.h"


//聊天所需要数据库
#import "SGroupDB.h"
#import "SGroupMemberDB.h"
#import "SGroupMessageDB.h"
#import "SFirendDB.h" //输入单词错误 请忽略
#import "SOneForOneMessageDB.h"
#import "SNotificationMessage.h"
#import "SMonitorExerciseDB.h"
#import "Exercise.h"
#import "SSleepingDB.h"
#import "Sleeping.h"

#import "CommonUtil.h"


#import "ClientHelper.h"

#define kSleepIsSleepSelect 30
UIBackgroundTaskIdentifier bgTask;
@interface AppDelegate ()
{
    CMMotionManager *motionManager;
    CMRotationMatrix rotation;
    
    //5s以上手机可用
    CMStepCounter *_stepCounter;
    NSInteger _stepsAtBeginOfLiveCounting;
    float px;
    float py;
    float pz;
    
    
    NSTimeInterval theLastSlientTime;
    NSTimeInterval theWakeupTime;
    BOOL isChange;
    BOOL isSleeping;
    BOOL startCountStepsAndSleep;
    //睡眠记录线程队列
    dispatch_queue_t sleepTimeSaveQueue;
    dispatch_group_t sleepGroup;
    __block bool sleepIsGo ;
    
    NSThread  * sleepThread;
}
@end

@implementation AppDelegate
            

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    // Override point for customization after application launch.
    
    
    //push register
    [BPush setupChannel:launchOptions]; // 必须
    
    [BPush setDelegate:self]; // 必须。参数对象必须实现onMethod: response:方法，本示例中为self
    
    // [BPush setAccessToken:@"3.ad0c16fa2c6aa378f450f54adb08039.2592000.1367133742.282335-602025"];  // 可选。api key绑定时不需要，也可在其它时机调用
    [self registerLocalNotification];
    [self initChatServerAndDB];
    
    //初始化聊天服务器以及本地聊天数据库
    [self initSleepDate];
    if (![CMStepCounter isStepCountingAvailable])
    {
        //初始化 自己编写的 后台运动动作
        [self initBackgroundStepsCountAndSleepTime];
    }else{
        //调用系统方法
        [self initCMSteps];
    }
    
    [[PHAppStartManager defaultManager] startApp];
    
    
    
    
    
    
    
    [self.window makeKeyAndVisible];
    return YES;
}

-(void)registerLocalNotification
{
#ifdef __IPHONE_8_0 //这里主要是针对iOS 8.0,相应的8.1,8.2等版本各程序员可自行发挥，如果苹果以后推出更高版本还不会使用这个注册方式就不得而知了……
    if ([[UIApplication sharedApplication] respondsToSelector:@selector(registerUserNotificationSettings:)]) {
        UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeBadge|UIUserNotificationTypeSound|UIUserNotificationTypeAlert categories:nil];
        [[UIApplication sharedApplication] registerUserNotificationSettings:settings];
    }
    else{
        UIRemoteNotificationType myTypes = UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeSound;
            [[UIApplication sharedApplication] registerForRemoteNotificationTypes:myTypes];
    }
#else
    UIRemoteNotificationType myTypes = UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeSound;
        [[UIApplication sharedApplication] registerForRemoteNotificationTypes:myTypes];
#endif
}


- (void)application:(UIApplication *)application
didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken
{
    
    [BPush registerDeviceToken:deviceToken]; // 必须
    
    [BPush bindChannel]; // 必须。可以在其它时机调用，只有在该方法返回（通过onMethod:response:回调）绑定成功时，app才能接收到Push消息。一个app绑定成功至少一次即可（如果access token变更请重新绑定）。
}

// 必须，如果正确调用了setDelegate，在bindChannel之后，结果在这个回调中返回。
// 若绑定失败，请进行重新绑定，确保至少绑定成功一次
- (void) onMethod:(NSString*)method response:(NSDictionary*)data
{
    if ([BPushRequestMethod_Bind isEqualToString:method])
    {
        NSDictionary* res = [[NSDictionary alloc] initWithDictionary:data];
        
        NSString *appid = [res valueForKey:BPushRequestAppIdKey];
        NSString *userid = [res valueForKey:BPushRequestUserIdKey];
        [CommonUtil localUserDefaultsValue:userid forKey:KMY_PUSH_USERID];
        NSString *channelid = [res valueForKey:BPushRequestChannelIdKey];
        [CommonUtil localUserDefaultsValue:channelid forKey:KMY_PUSH_CHANNELID];
        int returnCode = [[res valueForKey:BPushRequestErrorCodeKey] intValue];
        if(returnCode != BPushErrorCode_Success){
            [BPush bindChannel];
        }
        //NSString *requestid = [res valueForKey:BPushRequestRequestIdKey];
    }
}

- (void)application:(UIApplication *)application
didReceiveRemoteNotification:(NSDictionary *)userInfo
{
    [BPush handleNotification:userInfo]; // 可选
}


- (void)applicationWillResignActive:(UIApplication *)application {
    // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.
    // Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.
}

- (void)applicationDidEnterBackground:(UIApplication *)application {
    application.applicationIconBadgeNumber = 0;
    _isInitiativeExitChatConnect = YES;
    
    if (![CMStepCounter isStepCountingAvailable])
    {
        //修改 自己编写的 后台运动动作
        [motionManager stopAccelerometerUpdates];
        if (YES) {
            [ClientHelper close];
            //注册后台
            UIApplication*    app = [UIApplication sharedApplication];
            dispatch_queue_t lowQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);
            dispatch_async(lowQueue, ^{
                //启动
                [self doCounting];
                
            });
            bgTask = [app beginBackgroundTaskWithExpirationHandler:^{
                [app endBackgroundTask:bgTask];
                bgTask = UIBackgroundTaskInvalid;
            }];
        }
    }
    
    // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.
    // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
    // Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.
    if (YES) {//这里添加是否登录的判断较为合适
        [self performSelectorInBackground:@selector(reconnectToChatHost) withObject:nil];
    }
}

- (void)applicationDidBecomeActive:(UIApplication *)application {
    // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.
   
}

- (void)applicationWillTerminate:(UIApplication *)application {
    //保存健康数据
    //1.保存记步信息
    NSString * steps  = [NSString stringWithFormat:@"%ld",(long)_numSteps];
    [self saveStepsRightNow: steps];
    // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.
}
#pragma mark - 聊天服务器函数
//聊天服务器数据库初始化
-(void)initChatServerAndDB{
    //ClientHelper 初始化
    [ClientHelper initClient];
    
    //创建群组数据库
    SGroupDB *sgroupDB                = [[SGroupDB alloc]init];
    [sgroupDB createDataBase];
    SGroupMemberDB * sgroupMemberDB   = [[SGroupMemberDB alloc]init];
    [sgroupMemberDB createDataBase];
    SGroupMessageDB * sgroupMessageDB = [[SGroupMessageDB alloc]init];
    [sgroupMessageDB createDataBase];
    SFirendDB *sfriendDB              = [[SFirendDB alloc]init];
    [sfriendDB createDataBase];
    SOneForOneMessageDB * smeesageDB           = [[SOneForOneMessageDB alloc]init];
    [smeesageDB createDataBase];
    
    //91唱新增
    SNotificationMessage *snotifiDB = [[SNotificationMessage alloc]init];
    [snotifiDB createDataBase];
    
    //健康检查部分数据库
    SMonitorExerciseDB * smExerciseDB = [[SMonitorExerciseDB alloc]init];
    [smExerciseDB createDataBase];
    
    SSleepingDB * ssleepDB = [[SSleepingDB alloc]init];
    [ssleepDB createDataBase];
}
-(void)reconnectToChatHost{
    NSLog(@"reconnect chat host");
    [ClientHelper connectToHost];
}

#pragma mark - 计算步伐函数 自定义的
-(void)initBackgroundStepsCountAndSleepTime{
    
    motionManager = [[CMMotionManager alloc] init];
    motionManager.accelerometerUpdateInterval = 1.0 / 60.0;
    
//    UIApplication*    app = [UIApplication sharedApplication];
//    bgTask = [app beginBackgroundTaskWithExpirationHandler:^{
//        [app endBackgroundTask:bgTask];
//        bgTask = UIBackgroundTaskInvalid;
//    }];
    dispatch_queue_t lowQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);
    dispatch_async(lowQueue, ^{
        //
        [self doCounting];
    });

    [self saveStepsToDB];
}
-(void)doCounting{
    
    
    motionManager.deviceMotionUpdateInterval = 1 / 60;

    [motionManager startAccelerometerUpdatesToQueue:[NSOperationQueue mainQueue] withHandler:^(CMAccelerometerData *accelerometerData, NSError *error) {
        dispatch_async(dispatch_get_main_queue(), ^{
        
            float xx = accelerometerData.acceleration.x;
            float yy = accelerometerData.acceleration.y;
            float zz = accelerometerData.acceleration.z;
            
            
            NSLog(@"acceleration x %f y %f z %f ", xx,yy, zz);
            
            float dot = (px * xx) + (py * yy) + (pz * zz);
            float a = ABS(sqrt(px * px + py * py + pz * pz));
            float b = ABS(sqrt(xx * xx + yy * yy + zz * zz));
            
            dot /= (a * b);
            
            if (dot <= 0.81) {
                if (!isSleeping) {
                    isSleeping = YES;
                    [self performSelector:@selector(stepWakeUp) withObject:nil afterDelay:0.28];
                    _numSteps += 1;
                    NSLog(@"**********    %ld ****************",(long)_numSteps);
                }
            }
            px = xx; py = yy; pz = zz;
//            [self performSelector:@selector(createStartThreadToSaveStepsCountWhen24Clock) withObject:nil afterDelay:0.3];
            
        });
    }];
}
#pragma mark - 计算步伐 系统CMSteps
-(void)initCMSteps{
    //测试使用 观察键值
    [self addObserver:self forKeyPath:@"numSteps" options:NSKeyValueObservingOptionNew context:NULL];
    
    _stepCounter = [[CMStepCounter alloc] init];
    NSDate *now = [NSDate date];
    NSCalendar *calendar = [NSCalendar autoupdatingCurrentCalendar];
    NSDateComponents *components = [calendar components:NSYearCalendarUnit
                                    | NSMonthCalendarUnit
                                    | NSDayCalendarUnit
                                               fromDate:now];
    NSDate *beginOfDay = [calendar dateFromComponents:components];
    [_stepCounter queryStepCountStartingFrom:beginOfDay
                                          to:now
                                     toQueue:[NSOperationQueue mainQueue]
                                 withHandler:^(NSInteger numberOfSteps,
                                               NSError *error) {
                                     
                                     if (error)
                                     {
                                         NSLog(@"%@", [error localizedDescription]);
                                         self.numSteps = -1;
                                     }
                                     else
                                     {
                                         self.numSteps = numberOfSteps;
                                         [self _startLiveCounting];
                                     }
                                 }];
    //添加写数据库方法
    [self saveStepsToDB];
//    NSString * stringStep = [NSString stringWithFormat:@"%ld",(long)_numSteps];
//    NSTimeInterval timeinterval = [[NSDate date]timeIntervalSince1970];
//    int timeLeftToday = (long)timeinterval % 3600;
//    [self performSelector:@selector(createStartThreadToSaveStepsCountWhen24Clock:) withObject:stringStep afterDelay:timeLeftToday];
}
- (void)_startLiveCounting
{
    _stepsAtBeginOfLiveCounting = self.numSteps;
    [_stepCounter startStepCountingUpdatesToQueue:[NSOperationQueue mainQueue]
                                         updateOn:1
                                      withHandler:^(NSInteger numberOfSteps,
                                                    NSDate *timestamp,
                                                    NSError *error) {
                                          self.numSteps = _stepsAtBeginOfLiveCounting
                                          + numberOfSteps;
                                          NSLog(@"Number of steps add = %ld", (long)numberOfSteps);
                                      }];
    
    NSLog(@"Started live step counting");
}
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object
                        change:(NSDictionary *)change
                       context:(void *)context
{
//    NSLog(@"%ld",(long)self.numSteps);
    if ([self.delegate respondsToSelector:@selector(refreshStepsToday:)]) {
        [self.delegate refreshStepsToday:self.numSteps];
    }
    [self changeSleepQueue];
    
}
#pragma mark - 初始化睡眠统计queue
-(void)initSleepDate{
    theLastSlientTime = [[NSDate date]timeIntervalSince1970];
//    sleepTimeSaveQueue = dispatch_queue_create("sleepDateQueue", NULL);
//    sleepGroup = dispatch_group_create();
}
#pragma mark - 数据库处理步伐 睡眠
-(void)saveStepsToDB{
    NSString * stringStep = [NSString stringWithFormat:@"%ld",(long)_numSteps];
    NSTimeInterval timeinterval = [[NSDate date]timeIntervalSince1970];
    int timeLeftToday = (long)timeinterval % 3600;
    [self performSelector:@selector(createStartThreadToSaveStepsCountWhen24Clock:) withObject:stringStep afterDelay:timeLeftToday];
}
-(void)mergeSleepToDB{
    NSLog(@"%@",[CommonUtil TimeStrWithInterval:theLastSlientTime]);
    //获取当前时间
    SSleepingDB * sleepDB = [[SSleepingDB alloc]init];
    //查询数据库中是否存在 如果存在就修改 不存在就保存
    long long memberId = [[PHAppStartManager defaultManager] userHost] .memberId;
    if (![sleepDB isExistSleepingData:theWakeupTime WithBelongId:memberId]) {
        Sleeping * sleeping = [[Sleeping alloc]init];
        sleeping.belongMemberId = memberId;
        sleeping.lastSleepTime = theLastSlientTime ;
        
        sleeping.wakeupSleepTime = [[NSDate date]timeIntervalSince1970];
        [sleepDB saveSleeping:sleeping];
    }
//    else{
//        BOOL flag =[sleepDB mergeSleepingWakeupTimeTo:[[NSDate date]timeIntervalSinceNow] WithBelongId:memberId WithStartSleepTime:theLastSlientTime];
//        flag?NSLog(@"sleepDB 修改成功"):NSLog(@"sleepDB 修改失败");
//    }
    //更新最后安静时间
//    theLastSlientTime = [[NSDate date]timeIntervalSince1970];
    
    
}
-(void)changeSleepQueue{
     NSTimeInterval intverval = [[NSDate date]timeIntervalSince1970]- theLastSlientTime;
    
    if (intverval > kSleepIsSleepSelect) {
        //更新数据库
        [self mergeSleepToDB];
    }
     theLastSlientTime = [[NSDate date]timeIntervalSince1970];
    NSLog(@"%@",[CommonUtil TimeStrWithInterval:theLastSlientTime]);
//    //取消当前的保存方法
//    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(saveSleepToDB) object:nil];
    //新增一个保存方法
    
    
}
-(void)stepWakeUp{
    isSleeping = NO;
}
-(void)createStartThreadToSaveStepsCountWhen24Clock:(NSString *)steps{
    [self saveStepsRightNow:steps];
    //计算当前与下一个小时点的时间差
    [self performSelector:@selector(saveStepsRightNow:) withObject:steps afterDelay:3600];
    [self performSelector:@selector(clearStepsEvery24H) withObject:nil afterDelay:86400];
}
-(void)saveStepsRightNow:(NSString *)steps{
    //保存数据到数据库 一天存24次步伐数据
    SMonitorExerciseDB * smExerciseDB = [[SMonitorExerciseDB alloc]init];
    Exercise * exercise = [[Exercise alloc]init];
    long long memberId = [[PHAppStartManager defaultManager] userHost].memberId;
    if (memberId == 0) {
        return;
    }
    exercise.belongMemberId = memberId;
    exercise.createTime = [[NSDate date]timeIntervalSince1970];
    exercise.steps = [steps integerValue];
    [smExerciseDB saveMonitorExercise:exercise];
    
    //保存最后的活动时间到数据库 一天存24条
    
}
-(void)clearStepsEvery24H{
    _numSteps = 0;
}
@end
